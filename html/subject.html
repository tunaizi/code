<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <div id="sds">sds</div>
    <button id="btn">sdsds</button>
  </body>
</html>
<script>
  ;() => {
    window.onload = function () {
      "use strict"
      /**
       * 基于proxy 实现 发布订阅模式
       *
       * Publish/Subscribe
       * Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
       * ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
       * Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
       * ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。
       */

      class Subject {
        isArrs(subs) {
          return Array.isArray(subs) && subs.length
        }
        isFun(fn) {
          return fn instanceof Function
        }
        observer = {}
        constructor(obj = {}, transmit = "this is a first trigger msg", subs = []) {
          this.observer = this.observable(obj)
          transmit && this.setTransmit(transmit)
          this.isArrs(subs) && this.attach(...new Set(subs.filter(fn => this.isFun(fn))))
          !this.isArrs(subs) && this.isFun(subs) && this.attach(subs)
        }
        subs = new Set()
        transmit = null
        setTransmit(val) {
          this.transmit = val
        }
        dispatch(key, val) {
          this.observer[key] = val
        }
        getState() {
          return new Object(this.observer)
        }
        observable(obj) {
          console.log("---")
          const _this = this
          return new Proxy(obj, {
            set(target, key, value, receiver) {
              console.log("09099", target, key, value)
              const result = Reflect.set(target, key, value, receiver)
              _this.subs.size && _this.notify(_this.transmit)
              return result
            },
            get(targ, key, receiver) {
              // return Reflect.get(targ, key, receiver);
              return null
            }
          })
        }
        /**
         * 增加订阅者
         * @param observer
         */
        attach(...fns) {
          ;[...new Set(fns)].forEach(fn => this.subs.add(fn))
          return this
        }
        /**
         * 删除订阅者
         * @param observer
         */
        detach(...fns) {
          fns.length &&
            fns.forEach(fn => {
              this.subs.has(fn) && this.subs.delete(fn)
            })
          return this
        }
        /**
         * 通知订阅者更新消息
         */
        notify(transmit, ...all) {
          // console.log('---');
          transmit && this.setTransmit(transmit)
          all = [...new Set(all)]
          console.log(this.subs)
          this.subs.forEach(observer =>
            all.length ? (all.find(obs => obs === observer) ? observer(transmit) : null) : observer(transmit)
          )
        }
      }

      const zhangsan = new Proxy(
        new Subject(
          {
            name: "张三",
            age: 20
          },
          "你好张三",
          print1
        ),
        {
          get(target, property) {
            if (
              ["observable", "transmit", "notify", "isArrs", "isFun", "setTransmit", "observable"].includes(property)
            ) {
              return null
            } else {
              return Reflect.get(target, property)
            }
          }
        }
      )
      function print1(msg) {
        console.log(zhangsan.getState())
        console.log(msg)
      }
      function print2(msg) {
        console.log(zhangsan.getState())
        console.log(msg)
      }

      zhangsan.attach(print2)
      console.log(zhangsan, "zhangsan")
      setTimeout(() => {
        zhangsan.dispatch("name", "0893r73890")
      }, 3e3)

      /**
       * 基于proxy 实现 CreateElement
       *
       */

      const dom = new Proxy(
        {},
        {
          get(target, property) {
            return function (attrs = {}, ...children) {
              const el = document.createElement(property)
              for (let prop of Object.keys(attrs)) {
                el.setAttribute(prop, attrs[prop])
              }
              for (let child of children) {
                if (typeof child === "string") {
                  child = document.createTextNode(child)
                }
                el.appendChild(child)
              }
              return el
            }
          }
        }
      )

      const el = dom.div(
        {},
        "Hello, my name is ",
        dom.a({ href: "//example.com" }, "person.name"),
        ". I like:",
        dom.ul({}, dom.li({}, "person.age"), dom.li({}, "Food"), dom.li({}, "…actually thats it"))
      )

      document.body.appendChild(el)
      const sda = document.getElementById("btn")
      sda.onclick = function () {
        console.log(zhangsan)
        // zhangsan.dispatch('name', "0893345353r73890");
        // obj.name = 231
      }
    }
  }
  /*  */
  ;("-------------------")
  class Subject {
    queuedObservers = {}
    typeof(v) {
      const _toString = Object.prototype.toString
      return _toString.call(v).slice(8, -1)
    }
    observe(key, value) {
      const self = this
      Reflect.has(self.queuedObservers, key) && self.typeof(value) == "Function" && (self.queuedObservers[key] = value)
    }
    setMethod(target, key, value, receiver) {
      const self = this
      const result = Reflect.set(target, key, value, receiver)
      Object.values(self.queuedObservers).forEach(observer => observer(target))
      return result
    }
    getMethod(target, key) {
      const self = this
      return key == "add" ? self.observe : null
    }
    observable(obj) {
      const self = this
      return new Proxy(obj, { set: self.setMethod, get: self.getMethod })
    }
    constructor(obj = {}, funs = {}) {
      const self = this
      if (self.typeof(obj) != "Object") return null
      if (self.typeof(funs) != "Object") funs = {}
      Object.entries(funs).forEach(e => self.observe(...e))
      return self.observable(obj)
    }
  }
</script>
